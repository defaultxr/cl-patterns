;;; cl-patterns-skeletons.el --- collection of skeletons  -*- lexical-binding: t; -*-

;; Copyright (C) 2021 modula t.

;; Author: modula t. <defaultxr AT gmail DOT com>
;; Homepage: https://github.com/defaultxr/cl-patterns
;; Version: 0.5
;; Package-Requires: ((s "1.0") (emacs "24.4"))
;; Keywords: convenience, lisp

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; These are just a few skeletons for various cl-patterns-related constructs.
;; They're designed to be as "smart" as possible, i.e. by prompting for paths
;; when appropriate, inserting correct pattern parameters based on synthdefs,
;; etc.

;;; Code:

(require 'cl-patterns-helpers)

(defgroup cl-patterns nil
  "cl-patterns helper functionality."
  :group 'external
  :prefix "cl-patterns-")

(defcustom cl-patterns-bdef-default-directory nil
  "The directory that `bdef-skeleton''s filename completion should start from. If nil (the default), start from the current buffer's directory instead."
  :type '(choice directory (const nil)))

(defcustom cl-patterns-skeleton-name-generator 'cl-patterns-generate-random-string
  "The function that is used to generate a default name for a pb or other named construct when the user supplies only an apostrophe."
  :type '(function))

(defun cl-patterns-read-skeleton-name (prompt history default-value)
  "Prompt the user for a name for the construct being generated by a skeleton. If the user enters just an apostrophe, a random name is generated with `cl-patterns-skeleton-name-generator'."
  (let ((res (read-string promp nil history default-value)))
    (if (string= res "'")
        (funcall cl-patterns-skeleton-name-generator)
      res)))

(define-skeleton tempo-skeleton
  "Insert (tempo ...) with the current *clock* tempo."
  ""
  "(tempo " (number-to-string (or (cl-patterns-lisp-eval `(cl:* 60 (cl-patterns:tempo cl-patterns:*clock*))) 110)) _ "/60)")

(define-skeleton bdef-skeleton
  "Prompt for a file, then insert (bdef ...) that loads said file."
  ""
  "(bdef "
  (let* ((filename (read-file-name "bdef file? " cl-patterns-bdef-default-directory))
         (filename-base (file-name-base filename))
         (sym (concat ":" (cl-patterns-friendly-string filename-base))))
    (concat sym " \"" (replace-regexp-in-string "\"" "\\\"" filename t t) "\""))
  ")")

(define-skeleton pb-skeleton
  "Insert (pb ...), prompting for a name and an instrument."
  ""
  "(pb " (cl-patterns-read-skeleton-name "pb name? " 'cl-patterns-name-history (list (cl-patterns-guess-pdef)))
  "
  :instrument :" (let* ((instrument (completing-read "Instrument: "
                                                     (cl-patterns-lisp-eval
                                                      `(cl:mapcar 'cl:string-downcase (cl-patterns:all-instruments)))
                                                     nil nil))
                        (args (cl-patterns-lisp-eval `(cl:mapcar
                                                       (cl:lambda (x)
                                                                  (cl:symbol-name (cl:car (alexandria:ensure-list x))))
                                                       (cl-patterns::backend-instrument-controls (cl:intern ,(upcase instrument) :keyword) (cl:car (cl-patterns:enabled-backends))))))
                        (buf-arg (or (member "BUFFER" args)
                                     (member "BUFNUM" args))))
                   (concat instrument (when buf-arg
                                        (concat "\n  :" (downcase (car buf-arg)) " " (cl-patterns-guess-bdef))))) "
  :dur 1" _ "
  :pfindur 4)")

(define-skeleton pt-skeleton
  "Insert a basic ptracker pattern."
  ""
  "(pdef :" _ "
    (ptracker
     (list :note 0 :dur 1/4 :instrument :" (cl-patterns-guess-instrument) ")
     #T(- ;; 0
        -
        -
        -
        - ;; 4
        -
        -
        -
        - ;; 8
        -
        -
        -
        - ;; 12
        -
        -
        -
        )))")

(provide 'cl-patterns-skeletons)
;;; cl-patterns-skeletons.el ends here
