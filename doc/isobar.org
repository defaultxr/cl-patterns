#+TITLE: isobar
#+DESCRIPTION: cl-patterns equivalents for isobar pattern classes
#+OPTIONS: num:nil

[[https://github.com/ideoforms/isobar][isobar]] is another SuperCollider-inspired pattern sequencing system. It is written in (and with) Python. The following is isobar's list of its included pattern classes, and for each, the equivalent cl-patterns pattern is listed, if applicable. I haven't used a lot of isobar, though, so it's entirely possible some of these equivalents are wrong.

* CORE (core.py)
** ~Pattern~ - ~pattern~
Abstract superclass of all pattern generators.
** ~PConstant~ - ~pn~
Returns a fixed value.
** ~PRef~ - ~pdef~
Contains a reference to another pattern, which can be replaced dynamically.
** ~PFunc~ - ~pfunc~
Returns the value generated by a function.
** ~PArrayIndex~ - ~pindex~
Request a specified index from an array.
** ~PDict~ - ~pbind~
Construct a pattern from a dict of arrays, or an array of dicts.
** ~PDictKey~ - ~pk~
Request a specified key from a dictionary.
** ~PConcatenate~ - ~pseq~
Concatenate the output of multiple sequences.
** ~PAbs~ - ~(pnary 'abs ...)~
Absolute value of `input`
** ~PInt~ - ~(pnary 'floor ...)~
Integer value of `input`
** ~PAdd~ - ~(p+ ...)~
Add elements of two patterns (shorthand: patternA + patternB)
** ~PSub~ - ~(p- ...)~
Subtract elements of two patterns (shorthand: patternA - patternB)
** ~PMul~ - ~(p* ...)~
Multiply elements of two patterns (shorthand: patternA * patternB)
** ~PDiv~ - ~(p/ ...)~
Divide elements of two patterns (shorthand: patternA / patternB)
** ~PFloorDiv~ - ~(pnary 'floor (p/ ...))~
Integer division (shorthand: patternA // patternB)
** ~PMod~ - ~(pnary 'mod ...)~ or ~pwrap~
Modulo elements of two patterns (shorthand: patternA % patternB)
** ~PPow~ - ~(pnary 'expt ...)~
One pattern to the power of another (shorthand: patternA ** patternB)
** ~PLShift~ -
Binary left-shift (shorthand: patternA << patternB)
** ~PRShift~ -
Binary right-shift (shorthand: patternA << patternB)
** ~PEqual~ - ~peql~
Return 1 if a == b, 0 otherwise (shorthand: patternA == patternB)
** ~PNotEqual~ - ~p/=~
Return 1 if a != b, 0 otherwise (shorthand: patternA != patternB)
** ~PGreaterThan~ - ~p>~
Return 1 if a > b, 0 otherwise (shorthand: patternA > patternB)
** ~PGreaterThanOrEqual~ - ~p>=~
Return 1 if a >= b, 0 otherwise (shorthand: patternA >= patternB)
** ~PLessThan~ - ~p<~
Return 1 if a < b, 0 otherwise (shorthand: patternA < patternB)
** ~PLessThanOrEqual~ - ~p<=~
Return 1 if a <= b, 0 otherwise (shorthand: patternA <= patternB)

* SCALAR (scalar.py)
** ~PChanged~ -
Outputs a 1 if the value of a pattern has changed.
** ~PDiff~ - ~pdiff~
Outputs the difference between the current and previous values of an input pattern
** ~PSkipIf~ - 
If `skip` is false, returns `input`; otherwise, returns None.
** ~PNormalise~ -
Adaptively normalise `input` to [0..1] over a linear scale.
** ~PMap~ -
Apply an arbitrary function to an input pattern.
** ~PMapEnumerated~ -
Apply arbitrary function to input, passing a counter.
** ~PLinLin~ -
Map `input` from linear range [a,b] to linear range [c,d].
** ~PLinExp~ -
Map `input` from linear range [a,b] to exponential range [c,d].
** ~PRound~ -
Round `input` to N decimal places.
** ~PScalar~ -
Reduce tuples and lists into single scalar values,
** ~PWrap~ - ~pwrap~
Wrap input note values within <min>, <max>.
** ~PIndexOf~ -
Find index of items from `pattern` in <list>

* SEQUENCE (sequence.py)
** ~PSeries~ - ~pseries~
Arithmetic series, beginning at `start`, increment by `step`
** ~PRange~ - ~pseries*~
Similar to PSeries, but specify a max/step value.
** ~PGeom~ - ~pgeom~
Geometric series, beginning at `start`, multiplied by `step`
** ~PImpulse~ -
Outputs a 1 every <period> events, otherwise 0.
** ~PLoop~ -
Repeats a finite `pattern` for `n` repeats.
** ~PPingPong~ -
Ping-pong input pattern back and forth N times.
** ~PCreep~ -
Loop `length`-note segment, progressing `creep` notes after `repeats` repeats.
** ~PStutter~ - ~pr~
Play each note of `pattern` `count` times.
** ~PSubsequence~ -
Returns a finite subsequence of an input pattern.
** ~PReverse~ -
Reverses a finite sequence.
** ~PReset~ -
Resets `pattern` whenever `trigger` is true
** ~PCounter~ -
Increments a counter by 1 for each zero-crossing in `trigger`.
** ~PCollapse~ -
Skip over any rests in `input`
** ~PNoRepeats~ -
Skip over repeated values in `input`
** ~PPad~ -
Pad `pattern` with rests until it reaches length `length`.
** ~PPadToMultiple~ -
Pad `pattern` with rests until its length is divisible by `multiple`.
** ~PArpeggiator~ -
Arpeggiator.
** ~PEuclidean~ - ~pbjorklund~
Generate Euclidean rhythms.
** ~PPermut~ -
Generate every permutation of `count` input items.
** ~PPatternGeneratorAction~ -
Each time its pattern is exhausted, request a new pattern by calling <fn>.
** ~PSequenceAction~ -
Iterate over an array, perform a function, and repeat.

* CHANCE (chance.py)
** ~PWhite~ - ~pwhite~
White noise between `min` and `max`.
** ~PBrown~ - ~pbrown~
Brownian noise.
** ~PCoin~ -
Coin toss, returning either 0 or 1 given some `probability`.
** ~PWalk~ - ~pwalk~
Random walk around list.
** ~PChoice~ - ~pwrand~
Pick a random element from `values`, weighted by optional `weights`.
** ~PSample~ -
Pick multiple random elements from `values`, weighted by optional `weights`,
** ~PShuffle~ - ~pshuf~
Shuffled list.
** ~PShuffleInput~ -
Every `n` steps, take `n` values from `pattern` and reorder.
** ~PSkip~ -
Skip events with some probability, 1 - <play>.
** ~PFlipFlop~ -
flip a binary bit with some probability.
** ~PSwitchOne~ -
Capture `length` input values; loop, repeatedly switching two adjacent values.

* TONAL (tonal.py)
** ~PDegree~ -
Map scale index <degree> to MIDI notes in <scale>.
** ~PFilterByKey~ -
Filter notes based on their presence in <key>.
** ~PNearestNoteInKey~ -
Return the nearest note in <key>.
** ~PMidiNoteToFrequency~ -
Map MIDI note to frequency value.

* STATIC (static.py)
** ~PGlobals~ -
Static global value identified by a string.
** ~PCurrentTime~ - ~pbeat*~
Returns the position (in beats) of the current timeline.

* FADE (fade.py)
** ~PFadeNotewise~ -
Fade a pattern in/out by introducing notes at a gradual rate.
** ~PFadeNotewiseRandom~ -
Fade a pattern in/out by gradually introducing random notes.

* MARKOV (markov.py)
** ~PMarkov~ -
First-order Markov chain generator.

* LSYSTEM (lsystem.py)
** ~PLSystem~ -
integer sequence derived from Lindenmayer systems

* WARP (warp.py)
** ~PWInterpolate~ -
Requests a new target warp value from `pattern` every `length` beats
** ~PWSine~ -
Sinosoidal warp, period `length` beats, amplitude +/-<amp>.
** ~PWRallantando~ -
Exponential deceleration to <amp> times the current tempo over `length` beats.
